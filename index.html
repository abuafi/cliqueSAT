<!DOCTYPE html>
<html>
    <head>
        <link rel="stylesheet" href="./style/main.css">
        <script src="./solver/sat.js" rel="text/javascript"></script>
        <script src="./kdtree/kdTree.js" rel="text/javascript"></script>
        <script src="./graph.js" rel="text/javascript"></script>
        <script src="./clique.js" rel="text/javascript"></script>
        <script src="./clique_alt.js" rel="text/javascript"></script>
    </head>
    <body>
        <div id="content">
            <h1>K-Clique solver</h1>
            <div id="canvas_wrapper"><canvas id="canvas" width="500", height="500"></canvas></div>
            <span> k = <input class="input" id="k_selector" type="number" value="1" min="1" max="1"></span>
            <button class="input" id="solve_btn">Solve!</button>
            <div>
                <button disabled class="solve_setter" id="set_solve_1">Method 1</button>
                <button class="solve_setter" id="set_solve_2">Method 2</button></div>
        </div>
    </body>
    <script>
        setSolve1 = document.getElementById("set_solve_1")
        setSolve2 = document.getElementById("set_solve_2")
        solverSetters = document.getElementsByClassName("solve_setter")
        let solveFun = solve
        function setSolveFun(fun, e) {
            e.preventDefault()
            for (button of solverSetters) {
                button.disabled = false
            }
            e.srcElement.disabled = true
            solveFun = fun
        }
        setSolve1.addEventListener("click", e => setSolveFun(solve, e))
        setSolve2.addEventListener("click", e => setSolveFun(solve_alt, e))
        
        const vertexColor = [0, 255, 0]
        const highlightEdgeColor = [255, 0, 0]
        const edgeColor = [0, 0, 0]
        const phantomOpacity = 0.3
        kSelector = document.getElementById("k_selector")
        canvas = document.getElementById("canvas")
        canvasW = document.getElementById("canvas_wrapper")
        context = canvas.getContext('2d')
        const vertexRadius = 8
        startBtn = document.getElementById("solve_btn")
        startBtn.addEventListener("click", () => runSolver())
        class Vertex {
            x; y; i
            color = vertexColor
            draw(opacity = 1) {
                context.beginPath();
                let x = realX(this)
                let y = realY(this)
                context.arc(x, y, vertexRadius, 0, 2 * Math.PI, false);
                context.fillStyle = `rgba(${this.color[0]}, ${this.color[1]}, ${this.color[2]}, ${opacity})`
                context.fill();
                context.lineWidth = 1;
                context.strokeStyle = "black";
                context.stroke()
            }
            move(x,y) {
                this.x = x 
                this.y = y
            }
            constructor(x,y,i) {
                this.x = x
                this.y = y
                this.i = i
            }
        }
        class Edge {
            vertex1; vertex2; color = edgeColor
            constructor(v1,v2) {
                this.vertex1 = v1 
                this.vertex2 = v2
            }
            getVertex1() {
                if (this.vertex1 == -1 || draggingVertex && vertices[this.vertex1].i == mouseDownVertex.i) {
                    return phantomVertex
                } else {
                    return vertices[this.vertex1]
                }
            }
            getVertex2() {
                if (this.vertex2 == -1 || draggingVertex && vertices[this.vertex2].i == mouseDownVertex.i) {
                    return phantomVertex
                } else {
                    return vertices[this.vertex2]
                }
            }
            draw(opacity = 1) {
                let x1 = realX(this.getVertex1())
                let y1 = realY(this.getVertex1())
                let x2 = realX(this.getVertex2())
                let y2 = realY(this.getVertex2())
                context.beginPath();
                context.moveTo(x1, y1);
                context.lineTo(x2, y2);
                context.strokeStyle = `rgba(${this.color[0]}, ${this.color[1]}, ${this.color[2]}, ${opacity})`
                this.color = edgeColor
                context.stroke();
            }
        }
        function realY(o) { return o.y*canvas.height }
        function realX(o) { return o.x*canvas.width }
        function euclidean(va, vb) {
            return Math.sqrt(Math.pow(realX(va)-realX(vb),2)+Math.pow(realY(va)-realY(vb),2))
        }
        const vertices = []
        const edges = []
        const vertexTree = new kdTree([], euclidean, ['x','y'])
        function runSolver() {
            k = kSelector.value
            solution = solveFun()
            if (solution) {
                solution = solution.slice(0,k)
                highlight(solution)
            }
            drawCanvas()
        }
        function addVertex(x,y) {
            let i = instanceVertexCount
            let newVertex = new Vertex(x,y,i)
            vertices[i] = newVertex
            vertexTree.insert(newVertex)
            setVertexCount(i+1)
            kSelector.max = i+1
            return newVertex
        }
        function haveSameVertices(e1,e2) {
            return (e1.vertex1 == e2.vertex1 && e1.vertex2 == e2.vertex2) || (e1.vertex2 == e2.vertex1 && e1.vertex1 == e2.vertex2)
        }
        function drawCanvas() {
            context.clearRect(0,0,canvas.width,canvas.height)
            let phantomDragVertex = dragging && draggingVertex
            let phantomDragEdge = dragging && !draggingVertex
            for (edge of edges) {
                if (phantomDragEdge && haveSameVertices(edge, phantomEdge)) continue
                edge.draw()
            }
            if (phantomDragEdge) phantomEdge.draw(phantomOpacity)
            for (vertex of vertices) {
                if (phantomDragVertex && vertex.i == mouseDownVertex.i) continue
                vertex.draw()
            }
            if (phantomDragVertex) phantomVertex.draw(phantomOpacity)
        }
        function getCanvasCoord(e) {
            return {x: e.offsetX/canvas.width, y: e.offsetY/canvas.height}
        }
        var mouseDownTime
        var mouseDownVertex
        var dragging = false
        var draggingCreated = false
        var draggingVertex = false
        var mouseDownPos
        var mouseDragPos
        function canvasMouseDown(e) {
            e.preventDefault()
            if (dragging) return;
            dragging = true
            mouseDownTime = e.timeStamp
            let pos = getCanvasCoord(e)
            phantomVertex.move(pos.x, pos.y)
            mouseDownPos = pos
            let found = vertexTree.nearest(getCanvasCoord(e), 1, snap)
            if (found.length) {
                mouseDownVertex = found[0][0]
                draggingCreated = false
            } else {
                mouseDownVertex = addVertex(pos.x,pos.y)
                draggingCreated = true
            }
            canvasAfter()
        }
        const snap = 50
        function canvasMouseUp(e) {
            phantomEdge.vertex1 = -1
            phantomEdge.vertex2 = -1
            dragging = false
            e.preventDefault()
            let pos = getCanvasCoord(e)
            let found = vertexTree.nearest(pos, 1, snap)
            if (found.length) {
                let foundVertex = found[0][0]
                if (foundVertex != mouseDownVertex) {
                    if (connected(mouseDownVertex.i, foundVertex.i)) {
                        let {v1, v2} = removeEdge(mouseDownVertex.i, foundVertex.i)
                        let toRemove = edges.findIndex(e => e.vertex1 == v1 && e.vertex2 == v2)
                        for (let i = toRemove; i < edges.length-1; i++) {
                            edges[i] = edges[i+1]
                            edges[i].i--
                        }
                        edges.pop()
                    } else {
                        newEdge = addEdge(mouseDownVertex.i, foundVertex.i)
                        edges.push(new Edge(newEdge.v1, newEdge.v2))
                    }
                }
            }  else {
                if (!draggingCreated) {
                    vertexTree.remove(mouseDownVertex)
                    mouseDownVertex.move(pos.x, pos.y)
                    vertexTree.insert(mouseDownVertex)
                }
            }
            canvasAfter()
        }
        var phantomVertex = new Vertex(-1,-1,-1)
        var phantomEdge = new Edge(-1, -1)
        function canvasMouseDrag(e) {
            if (dragging) {
                let pos = getCanvasCoord(e)
                let found = vertexTree.nearest(pos, 1, snap)
                phantomVertex.move(pos.x, pos.y)
                if (!draggingCreated && !found.length) {
                    draggingVertex = true
                } else {
                    mouseDragPos = pos
                    draggingVertex = false
                    phantomEdge.vertex1 = mouseDownVertex.i
                    if (found.length) phantomEdge.vertex2 = found[0][0].i
                    else phantomEdge.vertex2 = -1
                }
                canvasAfter()
            }
        }
        function canvasAfter() {
            drawCanvas()
        }
        function setupCanvas() {
            canvas.addEventListener("mousedown", canvasMouseDown)
            canvas.addEventListener("mouseup", canvasMouseUp)
            canvas.addEventListener("mousemove", canvasMouseDrag)
        }
        window.onload = function () {
            canvas.width = canvasW.clientWidth
            canvas.height = canvasW.clientHeight
            setupCanvas()
            drawCanvas()
        }
        window.onresize= function () {
            canvas.width = canvasW.clientWidth
            canvas.height = canvasW.clientHeight
            drawCanvas()
        }
        function highlight(vertices) {
            firstVertexFound = (edge) => vertices.find(v => edge.vertex1 == v) != undefined
            secondVertexFound = (edge) => vertices.find(v => edge.vertex2 == v) != undefined
            for(edge of edges) {
                if (firstVertexFound(edge) && secondVertexFound(edge)) {
                    edge.color = highlightEdgeColor
                    redraw = true
                }
            }
        }

    </script>
</html>


