\documentclass[table]{article}

\usepackage[table]{xcolor}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{tabularx}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{bytefield}
\usetikzlibrary{calc,positioning,arrows,fit}
\usepackage[margin=2cm]{geometry}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{multicol}
\usepackage[colorlinks,urlcolor=blue,hypertexnames=true]{hyperref}
\usepackage{ifthen}
\usepackage{fancyhdr}
\usepackage{subcaption}
\usepackage{soul}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{graphicx}
\usepackage{hyperref}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\newcommand{\TRUE}{\text{TRUE}}
\newcommand{\FALSE}{\text{FALSE}}
\tikzstyle{state} = [draw=black,thick,text=black,circle,minimum size=20pt, inner sep = 0, font=\itshape]
% \tikzstyle{final} = [double, double distance=2pt]
% \tikzstyle{label} = [->,fill=white, circle, font=\small,scale=0.9, inner sep = 1pt]
\tikzset{semithick, node distance=50pt}

\lstset{
  frame=tb,
  language=Java,
  aboveskip=10mm,
  belowskip=10mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=8
}

\title{Theory of Computation - Assignment 6}
% \author{}

\pagestyle{fancy}
\fancyhf{}
\lhead{Theory of Computation - Assignment 6}
% \rhead{Ian Abuaf Pelo}
\rfoot{\thepage}

\begin{document}
\maketitle
\section{INTRODUCTION}
The clique problem is the computational problem of finding cliques in a graph. Given an undirected graph with N nodes and E edges and a value K, the task is to print all set of nodes which form a K size clique. 

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.7]{MrlSG.png}
    \caption{Example of a clique.}\label{f1}
\end{figure}

A clique C of a graph G is usually defined as a subset of the vertex set of G (V(G)) such that every pair of distinct vertices in C is adjacent in G (That is, two vertices u,v $\in$ C and u$\neq$v implies that u,v $\in$ E(G)). In other words, a subset of the vertex set of G is a clique if and only if its induced subgraph is a complete graph, that is if all distinct vertices are joined by and edge.
\\
The input of the k-clique problem is an undirected graph and a number k. 
An undirected graph is formed by a finite set of vertices and a set of unordered pairs of vertices, which are called edges. 
The output is a list of $k$ vertices which form a clique, if one exists, or a \lstinline{false} otherwise.

\section{REDUCTION: 3-SAT TO K-CLIQUE}
\subsection{3-SAT}
SAT, or the Boolean satisfiability problem (sometimes called propositional satisfiability problem and abbreviated SATISFIABILITY, SAT or B-SAT), is the problem of determining if there exists an interpretation that satisfies a given formula in Boolean algebra (with unknown number of variables) whether it is satisfiable, that is, whether there is some combination of the (binary) values of the variables that will give 1.

In other words, it asks whether the variables of a given Boolean formula can be consistently replaced by the values TRUE or FALSE in such a way that the formula evaluates to TRUE. If this is the case, the formula is called satisfiable (SAT). On the other hand, if no such assignment exists, the function expressed by the formula is FALSE for all possible variable assignments and the formula is unsatisfiable (UNSAT).

For the rest of this report, we will be referring to the conjunctive normal form version of the SAT problem, or CNF-SAT, that is one where there are $m\in\mathbb{N}$ clauses of $n\in\mathbb{N}$ literals $L$ that are arranged in the following form:
\[ \bigwedge_{i<m}\bigvee_{j<n}L_i^j \]
Where a literal $L_i$ is either the variable $x_i$ of its negation $\neg x_i$.

Cook's theorem, formulated in 1971 by Stephen Cook in "The complexity of theorem-proving procedures"%\cite{cook} 
proves that the SAT problem is NP-complete, that is every NP-hard problem can be reduced to it in polynomial time.

3-SAT is simply the problem of solving a SAT instance with at most 3 variables, so where $n\leq3$. The following is an example of a 3-SAT problem:
%\cite{cnf}
\begin{align}
    (\neg x_1 \lor x_2 \lor x_3)\land(x_1 \lor \neg x_2 \lor x_3)\land(x_1 \lor x_2 \lor \neg x_3)\land(\neg x_1 \lor \neg x_2 \lor \neg x_3)\label{3sat}
\end{align}
This problem is satisfiable, for example for the values $x = [\TRUE, \TRUE, \FALSE]$. 
\subsection{3-SAT to k-clique}
We can reduce the 3-SAT problem to the k-clique problem to prove that it is NP-hard.

We do this by generating an instance of the k-clique problem from an instance of a 3-SAT problem in polynomial time. 
If we can do this and solve the clique problem in polynomial time then we can solve any instance of 3-SAT in polynomial time by transforming it to a k-clique instance with this same method.

For a CNF formula with $k$ clauses we can find this reduction by building a graph with the following features:
\begin{itemize}
    \item It is $k$-partite, that is for each clause of the 3-SAT problem there exists a group of indipendent vertices where no vertex is connected to another vertex of the same group.
    \item Each group or part consists of 3 vertices, each representing one literal of the corresponding clause.
    \item Each vertex is connected to all other vertices in differenct parts that represent compatible literals. Two literals are considered compatible if there could exists a solution where both are true, for example $x_1$, $\neg x_2$, $x_3$ are all compatible, while $x_1$ and $\neg x_1$ are not compatible.
\end{itemize}
Take the previous example of a 3-SAT problem (\ref{3sat}). Build the graph as defined above:

\begin{figure}[h]
\centering
\begin{tikzpicture}
\node[state] (a1) {$\neg x_1$};
\node[state, below of=a1] (a2) {$x_2$};
\node[state, below of=a2] (a3) {$x_3$};

\node[state, above right =1.5cm of a1] (b1) {$x_1$};
\node[state, right of=b1] (b2) {$\neg x_2$};
\node[state, right of=b2] (b3) {$x_3$};

\node[state, below right =1.5cm of b3] (c1) {$x_1$};
\node[state, below of=c1] (c2) {$x_2$};
\node[state, below of=c2] (c3) {$\neg x_3$};

\node[state, below right =1.5cm of a3] (d1) {$\neg x_1$};
\node[state, right of=d1] (d2) {$\neg x_2$};
\node[state, right of=d2] (d3) {$\neg x_3$};

% \draw (a1) to (b1);
\draw (a1) to (b2);
\draw (a1) to (b3);
% \draw (a1) to (c1);
\draw (a1) to (c2);
\draw (a1) to (c3);
\draw (a1) to (d1);
\draw (a1) to (d2);
\draw (a1) to (d3);
\draw[red] (b1) to (a2);
\draw (b1) to (a3);
\draw (b1) to (c1);
\draw[red] (b1) to (c2);
\draw (b1) to (c3);
% \draw (b1) to (d1);
\draw (b1) to (d2);
\draw (b1)[red] to (d3);
\draw (c1) to (b1);
\draw (c1) to (b2);
\draw (c1) to (b3);
\draw (c1) to (a2);
\draw (c1) to (a3);
% \draw (c1) to (d1);
\draw (c1) to (d2);
\draw (c1) to (d3);
\draw (d1) to (b2);
\draw (d1) to (b3);
\draw (d1) to (c2);
\draw (d1) to (c3);
\draw (d1) to (a2);
\draw (d1) to (a3);

% \draw (a2) to (b2);
\draw (a2) to (b3);
\draw (a2)[red] to (c2);
\draw (a2) to (c3);
% \draw (a2) to (d2);
\draw (a2)[red] to (d3);
\draw (b2) to (a3);
% \draw (b2) to (c2);
\draw (b2) to (c3);
\draw (b2) to (d2);
\draw (b2) to (d3);
\draw (c2) to (b3);
\draw (c2) to (a3);
\draw (c2) to (d2);
\draw (c2)[red] to (d3);
\draw (d2) to (b3);
\draw (d2) to (c3);
\draw (d2) to (a3);

\draw (a3) to (b3);
% \draw (a3) to (c3);
% \draw (a3) to (d3);
\draw (b3) to (a3);
% \draw (b3) to (c3);
% \draw (b3) to (d3);
\draw (c3) to (d3);
\end{tikzpicture}
\caption{3-SAT to k-clique reduction of example (\ref{f1})}
\end{figure}

Notice that for each clause, there exits a node with neighbours from eavery other part. 
Therefore, there exists a 4-clique and by taking the literals from the nodes in the clique we have a valid solution to the 3-SAT problem.
\section{K-CLIQUE TO SAT}


Given a graph G=(V,E) and a number k, we will have variables $x_{iv}$ for every 1$\leq$i$\leq$k and every v$\in$V. You should think of $x_{iv}$ as stating that v is the $ith$ vertex in the clique. We want to encode the following constraints:

\begin{enumerate}\leftskip=0.8in 
\item 	For each i, there is an $ith$ vertex in the clique: \[\forall i\in \{1,\dots,k\}, \; x_{i1} \lor x_{i2} \lor x_{i3} \lor \dots \lor x_{iv}\]
\item   For each i,j the $ith$ vertex is different from the $jth$ vertex: \[\forall v\in V, \forall(i,j)\in \{1,\dots,k\}, \; \neg x_{iv} \lor \neg x_{jv}\]
\item 	For each i,j, the $ith$ vertex is connected to the $jth$ vertex: \[\forall v\in V, \forall(i,j)\in \{1,\dots,k\}, \; \neg x_{iv} \lor x_{ju_1} \lor \dots \lor x_{ju_m}\], s.t. $u_{1,\dots,m}$ are the neighbours of $v$.
\end{enumerate}

\leftskip=0.5in
If we take all these clauses together, we get a CNF which states that "the $x_{iv}$ encode a k-clique in G". This CNF is satisfiable if and only if G contains a k-clique.
In order to get a 3CNF, we need to convert the constraints of the first kind into 3-clauses. If the vertices are $v_1$,...,$v_n$, we replace $V_{v \in V} x_{iv}$ with:

\begin{center}
$x_{iv_1} \lor x_{iv_2} \lor y_{iv_2} $ \newline
$\neg y_{iv_2} \lor x_{iv_3} \lor y_{iv_3} $ \newline
$\neg y_{iv_3} \lor x_{iv_4} \lor y_{iv_4} $ \newline
... \newline
$\neg y_{iv_{n-2}} \lor x_{iv_{n-1}} \lor x_{iv_n} $ \newline
\end{center}

No matter what value of y we choose. Each clause must have one true literal. To make this true, we need to decide if we need true or false value in the first clause, but for the rest, it will always be true, because each have y and Â¬y

\leftskip=0.5in 
Here the $y_{iv}$ are new variables. This set of clauses is equivalent to the original clause $x_{iv_1} \lor x_{iv_2} \lor ... \lor x_{iv_n} $.

\leftskip=0.0in  
\section{ALGORITHM}

\leftskip=0.5in  
We have found a solution, in which, for a complete graph with v vertices:
\begin{enumerate}\leftskip=0.8in 
\item We take all unconnected pair of vertices.
\item For each, at least one of them doesn't belong in a clique (If both did, it wouldn't be a clique since the two don't connect).
\item Then, check that at least k vertices are part of the clique.
\end{enumerate}

\leftskip=0.0in  
\section{CODE}

\leftskip=0.5in  
To solve the problem, we have created the following functions.
The \textit{solve()} function will create clauses for pairs of vertices that are not connected to each other. It will do this in the following way: \newline

\begin{itemize}\leftskip=0.8in
\item First we check that the size (which we have stored in the variable called "size") is equal to 0. If it is, we will return an error message since the network must contain at least one vertex (otherwise it is unsolvable and makes no sense).
\item If it is not, we continue.
\end{itemize}
 
\leftskip=0.5in
We will consider the vertices as a triangular matrix, in which in the first row will appear the connections that vertex 0 has, in the second row those of vertex 1, and so on until the last vertex (being 0 not connected with another vertex and 1 connected with another vertex).\newline

For example, if we have 5 vertices and vertex 0 is connected to vertices 1 and 3, the first column of the matrix will be the following: 0 1 0 1 0 0

Therefore, we will go through the matrix row by row and column by column, i.e. element by element. 

For each element of the matrix:

\begin{itemize}\leftskip=0.8in
\item If it is 1, i.e. the vertices are connected to each other, we continue.
\item If it is 0, i.e. the vertices are not connected, we create a clause, since that row and that column (i.e. that pair of vertices) cannot be in the clique.
\end{itemize}

\leftskip=0.5in
Then we call the function \textit{recursiveClaurses()}, this function computes the rest of the clauses to make sure that at least k variables are true.

Once we have this, we will join the clauses created for the unconnected vertices with the clauses for the connected vertices, which will form our solution.

We will pass these clauses created for a given size to the \textit{satSolve()} function. If it does not find a solution, no solution will be displayed, but if it does, it will be displayed. There may be more than one possible clique within a network for a given size k. This function will display one of the possible solutions at random.\newline

The code of the function is as follows:

\begin{lstlisting}
    Function solve() {
	let size = instanceVertexCount;
    	let clauses = []
        if (size == 0) throw("Graph must contain at least 1 vertex")
        for (row in instance) {
            for (col in instance[row]) {
                // For each possible combination of vertices
                if (!instance[row][col]) {
                    // If there is no edge create a clause
                    // "Either row or col are not in the clique"
                    clauses.push([-(parseInt(row)+1), -(parseInt(col)+1)])
                }
            }
        }
        let others = recursiveClauses(size - k + 1)
        clauses = clauses.concat(others)
        let solution = satSolve(size, clauses)
        if (!solution) return solution 
        return solution.filter(i => i>0).map(i => i-1)
    }

\end{lstlisting}

As we have already said, the function \textit{recursiveClaurses()} computes the rest of the clauses to make sure that at least k variables are true. 
We will call this function recursively, creating a vector for each iteration in which we will add clauses for each vertex, until we reach the last vertex where we will stop the recursion.

The code of the function is as follows:

\begin{lstlisting}
    function recursiveClauses(stop, v = [], j = 0) {
    let out = []
        if (v.length == stop) return [v]
        for (let i = j; i < instanceVertexCount; i++) {
            next = [...v]
            next.push(i+1)
            out = out.concat(recursiveClauses(stop, next, i+1))
        }
        return out
    }

\end{lstlisting}


\section{TEST CASES}

\begin{figure}[h]
    \centering
    \begin{subfigure}{0.49\linewidth}
        \scalebox{0.5}{\includegraphics{figures/Figure_insect_time.png}}
        \subcaption{Insect preset}
    \end{subfigure}
    \begin{subfigure}{0.49\linewidth}
        \scalebox{0.5}{\includegraphics{figures/Figure_icosagon_time.png}}
        \subcaption{Icosagon preset with full clique}
    \end{subfigure}
    \begin{subfigure}{0.49\linewidth}
        \scalebox{0.5}{\includegraphics{figures/Figure_icosagon_random_time.png}}
        \subcaption{Icosagon preset with random edges}
    \end{subfigure}
    \begin{subfigure}{0.49\linewidth}
        \scalebox{0.5}{\includegraphics{figures/Figure_fish_time.png}}
        \subcaption{Icosagon preset with random edges}
    \end{subfigure}
    \caption{Recorded times for the program to solve each preset at different values of $k$. (Times are given in milliseconds)}
\end{figure}

\begin{figure}[h]
    \centering
    \begin{subfigure}{0.49\linewidth}
        \scalebox{0.5}{\includegraphics{figures/Figure_insect_clauses.png}}
        \subcaption{Insect preset}
    \end{subfigure}
    \begin{subfigure}{0.49\linewidth}
        \scalebox{0.5}{\includegraphics{figures/Figure_fish_clauses.png}}
        \subcaption{Icosagon preset with random edges}
    \end{subfigure}
    \caption{Number of clauses generated by each preset at different values of $k$.}
\end{figure}

\newpage\section{BIBLIOGRAPHY}
\begin{itemize}
\item\href{https://en.wikipedia.org/wiki/Clique_problem}{Clique problem}    
\item\href{http://www.cs.ecu.edu/karl/6420/spr16/Notes/NPcomplete/3sat.html}{3 SAT}    
\item\href{https://www.geeksforgeeks.org/proof-that-clique-decision-problem-is-np-complete}{CLIQUE is NP-complete}    
\item\href{https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/threeSAT_to_clique.html}{SAT to clique}    
\item\href{https://paperzz.com/doc/7301675/3sat-reduction-to-clique}{reduction to clique} 
\item\href{https://en.wikipedia.org/wiki/Boolean_satisfiability_problem}{Boolean satisfiability problem}
\item\href{https://www.cs.umd.edu/~gasarch/TOPICS/sat/SATtalk.pdf}{SAT}
\item\href{https://logic4free.informatik.uni-kiel.de/llocs/Conjunctive_normal_form_(propositional_logic)}{cnf}
\item\href{https://cs.stackexchange.com/questions/70531/reduction-3sat-and-clique}{reduction 3 sat to clique}
\item\href{https://dl.acm.org/doi/10.1145/800157.805047}{cook}
\end{itemize}

\end{document}
